# Feature: Monitor Notification Preferences
> Specification generated by /interview on 2026-02-17
> This is a planning document. No implementation code has been written.

## Implementation Instructions
This specification is context for the implementing agent. Read and internalize it fully before writing any code.

**IMPORTANT — Do NOT:**
- Add comments referencing this spec (no `// See spec: ...`, no `// REQ-001`, no `// Don't #3`)
- Structure code around spec sections — structure it around clean domain logic
- Embed spec traceability IDs in code, comments, variable names, or test names
- Add comments explaining "why" when the code is self-documenting

**DO:**
- Write clean, idiomatic TypeScript that follows the reference implementation patterns
- Let the constraints from this spec guide your decisions silently — they should be invisible in the final code
- Name things after domain concepts, not spec concepts
- Write tests that verify behavior, named after what they verify (not after spec requirement IDs)

## Overview
Allow users to configure per-monitor notification preferences including quiet hours, change sensitivity thresholds, digest mode (batching notifications), and per-monitor notification email overrides. Currently monitors have only a boolean `emailEnabled` flag with no granularity.

## Scope
### In Scope
- Per-monitor quiet hours (suppress notifications during specified time window)
- Daily digest mode as alternative to immediate notifications
- Per-monitor notification email override (different from user's default `notificationEmail`)
- Change sensitivity threshold (ignore changes below a character-difference threshold)

### Out of Scope
- Webhook notification channels
- SMS or push notifications
- Team/shared notification channels
- Per-change-type notification rules (e.g., only notify on price changes)

### Deferred
- Notification templates (custom email body/subject per monitor)
- Notification history/audit log visible to users
- Slack/Discord integration

## Reference Implementation
- Reference: `server/services/email.ts` — notification delivery with tier-based caps, Resend API integration
- Also reference: `server/services/scheduler.ts` — how monitors are checked and changes detected
- Also reference: `server/routes.ts` — CRUD route handler patterns for monitors (create, update, get, delete)
- Replicate: route definition pattern in `shared/routes.ts`, storage methods in `server/storage.ts`, Zod validation, error response format

## Codebase Context
- Architecture: Monorepo with `client/`, `server/`, `shared/` — Express backend, React frontend, shared types
- ORM: Drizzle ORM with PostgreSQL (`server/db.ts` connection, `shared/schema.ts` definitions)
- API framework: Express 5 with `registerRoutes()` pattern in `server/routes.ts`
- Test framework: Vitest with co-located `*.test.ts` files
- Validation: Zod schemas in `shared/routes.ts`, `createInsertSchema` from `drizzle-zod`
- Error handling: `errorSchemas` object in `shared/routes.ts` with typed error responses, `ErrorLogger` service for system logging
- Frontend: React 18 + TanStack React Query + shadcn/ui components + Tailwind CSS

## Requirements
- Users can set quiet hours per monitor (start/end time in HH:MM format, user's local timezone)
- Users can enable digest mode per monitor (batch changes into a single daily email instead of immediate)
- Users can override the notification email per monitor (defaults to user's `notificationEmail`)
- Users can set a change sensitivity threshold (minimum character difference to trigger notification, inclusive: changes >= threshold trigger)
- Preferences are optional — monitors without explicit preferences use current default behavior
- The scheduler must check notification preferences before sending emails on detected changes

## Prohibitions (Don'ts)
- NEVER send notifications during a monitor's quiet hours — queue them for delivery when quiet hours end. Sending a 3am notification defeats the purpose.
- NEVER bypass tier-based email caps when processing digest batches — a digest with 10 changes still counts as 1 email against the cap, but the cap must be checked before sending.
- NEVER store timezone as an offset (e.g., UTC+5) — store the IANA timezone name (e.g., `America/New_York`) to handle DST transitions correctly.
- NEVER send digest emails for monitors with no changes in the digest period — empty digests are noise.
- NEVER allow a notification email override that hasn't been validated as a real email format — use Zod's `.email()` validator.
- NEVER delete notification preferences when a monitor is temporarily deactivated (`active: false`) — preferences should persist so reactivation restores the previous configuration.
- NEVER process notification preferences in the route handler — all notification logic belongs in the service layer (`server/services/email.ts` and `server/services/scheduler.ts`).

## Decision Tree
```
Change detected by scheduler
│
├── Monitor has notification preferences?
│   ├── NO → Use default behavior (immediate email if emailEnabled)
│   └── YES → Continue with preferences
│
├── Change meets sensitivity threshold? (change_size >= threshold)
│   ├── NO → Log as minor change, skip notification
│   └── YES → Continue
│
├── Digest mode enabled?
│   ├── YES → Queue change for next digest batch
│   │   └── Digest cron fires
│   │       ├── Any queued changes? → NO → Skip
│   │       └── YES → Continue to quiet hours check
│   └── NO → Continue to quiet hours check (immediate)
│
├── Currently in quiet hours?
│   ├── YES → Queue for delivery when quiet hours end
│   └── NO → Continue
│
├── Tier email cap reached?
│   ├── YES → Log warning, skip notification
│   └── NO → Send email
│       ├── Use override email if set
│       └── Fall back to user's notificationEmail
│
└── Log notification outcome
```

## Domain Rules & Exceptions
| Rule | Applies When | Exception | Who Can Override |
|------|-------------|-----------|-----------------|
| Quiet hours suppress notifications | Quiet hours configured and current time is within window | None — quiet hours are absolute | User can disable quiet hours by removing the preference |
| Digest batches sent once daily at 9am user-local | Digest mode enabled | If user changes timezone, next digest uses new timezone | None |
| Sensitivity threshold filters minor changes | Threshold > 0 configured | First-ever change for a monitor always triggers notification regardless of threshold | None |
| Email override must be valid format | Override email is set | None | None |
| Free tier: max 1 email per 24h per monitor | User tier is `free` | None | Upgrading to Pro/Power removes limit |

## Escalation & Guardrails
- **Fail if**: Notification preferences reference a monitor that doesn't exist (orphan data), email override fails Zod email validation
- **Queue for later if**: Currently in quiet hours (deliver when window ends), digest mode is on (deliver at next digest time)
- **Retry/degrade if**: Resend API returns 503 — follow existing retry pattern in `server/services/email.ts`
- **Alert if**: Digest batch processing takes more than 60 seconds (logged via `ErrorLogger.error()`), queued notifications older than 48 hours haven't been delivered

## Data Model
New table: `notification_preferences` — belongs to `monitors`, one-to-one relationship.

Fields and relationships — follow the Drizzle table definition pattern in `shared/schema.ts`:
- `id` (serial, primary key)
- `monitorId` (integer, not null, unique, FK to `monitors.id`, cascade delete)
- `quietHoursStart` (text, nullable) — "HH:MM" format, e.g., "23:00"
- `quietHoursEnd` (text, nullable) — "HH:MM" format, e.g., "07:00"
- `timezone` (text, nullable) — IANA timezone, e.g., "America/New_York"
- `digestMode` (boolean, default false, not null)
- `sensitivityThreshold` (integer, default 0, not null) — minimum character difference
- `notificationEmail` (text, nullable) — override email address
- `createdAt` (timestamp, defaultNow, not null)
- `updatedAt` (timestamp, defaultNow, not null)

New table: `notification_queue` — holds queued notifications for quiet hours and digest delivery.

Fields:
- `id` (serial, primary key)
- `monitorId` (integer, not null, FK to `monitors.id`, cascade delete)
- `changeId` (integer, not null, FK to `monitor_changes.id`)
- `reason` (text, not null) — "quiet_hours" or "digest"
- `scheduledFor` (timestamp, not null) — when to deliver
- `delivered` (boolean, default false, not null)
- `deliveredAt` (timestamp, nullable)
- `createdAt` (timestamp, defaultNow, not null)

Modified table: `monitors` — no schema changes needed. The `emailEnabled` boolean remains as a master on/off toggle. Notification preferences layer on top of it.

## API Contract
### GET /api/monitors/:id/notification-preferences
- Auth: Must be authenticated, must own the monitor
- Success: `200` — returns the notification preferences object (or defaults if none set)
- Errors: `404` if monitor not found, `401` if not authenticated

### PUT /api/monitors/:id/notification-preferences
- Auth: Must be authenticated, must own the monitor
- Request body:
  - `quietHoursStart` (string, optional, "HH:MM" format)
  - `quietHoursEnd` (string, optional, "HH:MM" format — both must be set or both null)
  - `timezone` (string, optional, IANA timezone name — required if quiet hours set)
  - `digestMode` (boolean, optional, defaults to false)
  - `sensitivityThreshold` (integer, optional, min 0, max 10000, defaults to 0)
  - `notificationEmail` (string, optional, must be valid email if provided)
- Success: `200` — returns updated notification preferences
- Errors: `404` if monitor not found, `422` if validation fails, `401` if not authenticated

### DELETE /api/monitors/:id/notification-preferences
- Auth: Must be authenticated, must own the monitor
- Success: `204` — preferences deleted, monitor reverts to default behavior
- Errors: `404` if monitor not found, `401` if not authenticated

## Frontend Changes
### Modified Components
- `CreateMonitorDialog.tsx` — add optional "Notification Settings" expandable section
- `MonitorDetails.tsx` — add notification preferences panel showing current settings with edit capability
- `MonitorCard.tsx` — add small icon indicator showing notification mode (immediate / digest / quiet hours active)

### New Components
- `NotificationPreferencesForm.tsx` — reusable form component for editing preferences, used in both CreateMonitorDialog and MonitorDetails
  - Time picker inputs for quiet hours (shadcn/ui time input)
  - Timezone selector dropdown
  - Toggle for digest mode
  - Slider or number input for sensitivity threshold
  - Email input with validation for override address

### State Management
- Add React Query hooks in a new `client/src/hooks/use-notification-preferences.ts`
- Follow the pattern in `client/src/hooks/use-monitors.ts` for query keys and mutations

## Acceptance Criteria
### Happy Path
- [ ] Given a monitor with quiet hours set to 23:00-07:00 EST, when a change is detected at 2:00 AM EST, then the notification is queued and delivered after 07:00 AM EST
- [ ] Given a monitor with digest mode enabled, when 3 changes are detected throughout the day, then a single digest email is sent at the next scheduled digest time
- [ ] Given a monitor with sensitivity threshold of 50, when a change of exactly 50 characters is detected, then a notification is sent (boundary is inclusive: change >= threshold)
- [ ] Given a monitor with a notification email override, when a change is detected, then the email is sent to the override address instead of the user's default

### Negative / Prohibition Tests
- [ ] Given a monitor in quiet hours, when a change is detected, then NO email is sent immediately — it MUST be queued
- [ ] Given a free-tier user who has already received 1 email in the past 24h for this monitor, when a digest batch is ready, then it is NOT sent — the cap is respected
- [ ] Given a notification email override of "not-an-email", when saving preferences, then validation MUST reject it with a 422 error
- [ ] Given a monitor with `active: false` and existing notification preferences, when the monitor is deactivated, then the preferences MUST persist in the database

### Edge Cases
- [ ] Given a monitor with no notification preferences set, when a change is detected, then the default behavior (immediate email if `emailEnabled`) is used — no regression
- [ ] Given quiet hours spanning midnight (23:00-07:00), when a change is detected at 23:30, then it is correctly identified as within quiet hours
- [ ] Given a sensitivity threshold of 50, when a change of 49 characters is detected, then a notification is NOT sent (below threshold)
- [ ] Given this is the first-ever change for a monitor with sensitivity threshold of 100, when a 10-character change is detected, then a notification IS sent (first change exception)

### Integration / Resilience
- [ ] Given the Resend API returns 503 during digest batch processing, then the failed notifications are retried following the existing retry pattern
- [ ] Given queued notifications older than 48 hours exist, then an error is logged via `ErrorLogger` for admin visibility
- [ ] Given a user changes their timezone, then the next quiet hours evaluation uses the new timezone correctly

## Files to Create / Modify (Implementation Plan)
- Create: `shared/schema.ts` additions — `notificationPreferences` and `notificationQueue` table definitions, relations, types
- Create: `shared/routes.ts` additions — Zod schemas and route definitions for notification preferences endpoints
- Modify: `server/storage.ts` — add CRUD methods for notification preferences and queue operations to `DatabaseStorage`
- Modify: `server/routes.ts` — register 3 new endpoints (GET, PUT, DELETE notification preferences)
- Modify: `server/services/scheduler.ts` — check notification preferences before triggering email, add digest cron job
- Modify: `server/services/email.ts` — add digest email formatting, quiet hours queue processing
- Create: `client/src/hooks/use-notification-preferences.ts` — React Query hooks for preferences CRUD
- Create: `client/src/components/NotificationPreferencesForm.tsx` — reusable preferences form
- Modify: `client/src/components/CreateMonitorDialog.tsx` — add notification settings section
- Modify: `client/src/pages/MonitorDetails.tsx` — add notification preferences panel
- Modify: `client/src/components/MonitorCard.tsx` — add notification mode indicator icon
- Create: `server/services/scheduler.test.ts` additions — tests for preference-aware scheduling
- Create: `server/services/email.test.ts` — tests for digest and quiet hours logic

## Observability
- Log (Info): Notification queued for quiet hours (monitorId, scheduledFor)
- Log (Info): Digest batch processed (userId, monitorCount, emailsSent)
- Log (Info): Change below sensitivity threshold, notification skipped (monitorId, changeDelta, threshold)
- Log (Warning): Queued notification older than 48h not yet delivered (notificationQueueId)
- Log (Warning): Digest batch processing slow (>30s) (batchSize, duration)
- Log (Error): Failed to deliver queued notification after retries (monitorId, error)
- Never log: User email addresses in plain text, notification email overrides in error contexts

## Key Decisions Made
| Decision | Options Considered | Chosen | Rationale |
|----------|-------------------|--------|-----------|
| Preferences storage | A) Columns on monitors table B) Separate preferences table C) JSON column | B) Separate table | Keeps monitors table clean, allows independent querying, easier to add fields later |
| Quiet hours handling | A) Drop notification B) Queue for later | B) Queue for later | Users want to be notified, just not at 3am — queuing preserves the alert |
| Digest scheduling | A) Fixed time (9am UTC) B) Fixed time in user timezone C) User-chosen time | B) Fixed time (9am) in user timezone | Respects local business hours without adding UI complexity |
| Sensitivity measure | A) Character count diff B) Percentage diff C) Semantic diff | A) Character count diff | Simple, predictable, easy to explain to users. `oldValue`/`newValue` are stored as text |
| Email override scope | A) Per-user B) Per-monitor | B) Per-monitor | Users may want different monitors sent to different addresses (work vs personal) |
| Timezone storage | A) UTC offset B) IANA timezone name | B) IANA timezone name | Handles DST transitions correctly — UTC offsets shift twice a year |

## Open Questions
- Should digest emails include a summary of all changes or just the latest value? Need UX input.
- Should the sensitivity threshold apply to the raw HTML/text or the visible text only? Need product decision.
- Should free-tier users have access to all notification preference features, or should some (like digest mode) be Pro-only? Need business input.
