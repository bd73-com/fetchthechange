We are building a generic “monitor any selector on any page” system, strict selector mode only (no inference, no guessing).

Current issue: we mark monitors as blocked based on the static fetch (“enable JavaScript”), and return Blocked/Unavailable without attempting Browserless, even when Browserless is enabled. This regresses behavior.

Please implement these changes:

1) Fix scraping control flow (blocked detection must not stop before Browserless)

In services/scraper.ts, refactor so extraction follows this exact pipeline:

Pipeline

Fetch static HTML (fetch/curl).

Parse and try to extract selector.

If selector found → return value.

If selector not found OR static blocked detected:

If BROWSERLESS_TOKEN is present → run Browserless render (including consent dismissal), then:

Re-check detectPageBlockReason() on the rendered DOM

Retry selector extraction on rendered DOM

If selector found → return value

If rendered still blocked → return Blocked/Unavailable

If rendered not blocked but selector missing → return null (selector missing)

If Browserless not configured → return Blocked/Unavailable only if static is blocked; otherwise return null.

Important: “blocked=true” should only be final if the rendered Browserless page is blocked OR Browserless is unavailable.

Add one structured log line that includes:

stage=static|rendered

selectorCount

blocked

reason

2) Add a strict debug endpoint (no inference)

Add an authenticated endpoint:
POST /api/monitors/:id/debug

It should:

Run the same pipeline as above

Return JSON:

{
  "url": "...",
  "selector": "...",
  "static": { "blocked": true/false, "reason": "...", "selectorCount": 0 },
  "rendered": { "used": true/false, "blocked": true/false, "reason": "...", "selectorCount": 0, "finalUrl": "...", "title": "..." }
}


Do not store anything in DB in debug mode.

This endpoint is for diagnosing why a selector fails.

3) Ensure response semantics are consistent

If rendered page is not blocked and selectorCount is 0 → return currentValue: null (meaning selector missing).

Only return Blocked/Unavailable when rendered is blocked or Browserless is unavailable.

No domain-specific logic. No inference. Keep it generic and deterministic.